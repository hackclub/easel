---
title: Orpheus writes an interpreter
order: 4
---

Orpheus has her smock and beret on today. She's ready to do some painting. She sits down at the computer. The smock is slightly awkward. The beret's about to fall off. 

But today's an exciting day! Because today, we'll get the interpreter up and running, and we'll be able to run programs for real now. And Orpheus will finally be able to get this easel to work.

## How the interpreter's going to work

The interpreter's going to be a little different from the lexer and parser, but not too different! It's going to take the nodes that the parser created, and make actual things happen. The best part is that it's surprisingly easy - we've done all the hard work in the parser and now we can glide on by, although it'll be bit longer-winded.

Orpheus opens up her computer. It's time to start writing the interpreter in `interpreter.js`:

```js
export class Interpreter {
  error(msg) {
    throw new EaselError(`Runtime error: ${msg}`)
  }

  run(ast, scope) {
  }
}
```

Just a little boilerplate here. Our main entry point is going to `run()`, which takes in the abstract syntax tree our lovely parser has created and something new: *scope*.

## So how does this scope thing work?

Scope is what's going to make magic. I mean, turn our programming language into a power to be reckoned with. Like an actual programming language - in fact, one of the biggest criteria for a language to be Turing-complete is that it should be able to keep track of state. That's what scope is for - it'll keep track of what variables exist, what functions exist, what structs exist, and any other info we'll have. It's also we'll inject our *standard library* into, as we'll see later.

We're going to use a simple key-value store to store our scope, especially since JavaScript is so lenient. While we're at it, let's add a quick util function to check if a value exists in our scope that'll come in handy later:

```js
export class Interpreter {
  // ...

  inScope(scope, name) {
    return Object.keys(scope).includes(name)
  }
}
```

## Let's get this working

Ok, awesome. How exactly should we go about doing this? Well, it's quite simple really - we're going to loop over every node, and run whatever is inside that node. We can take advantage of the fact that we have different kinds of nodes and do different things based on what the node needs. For example, say we have a while statement:

```plaintext
{
    "type": "While",
    "condition": {
      "type": "Binary",
      "left": { "type": "Var", "name": "countdown" },
      "operator": ">",
      "right": { "type": "Literal", "value": 0 }
    },
    "body": [
      {
        "type": "Call",
        "caller": { "type": "Var", "name": "ink" },
        "args": [{ "type": "Var", "name": "countdown" }]
      },
      {
        "type": "Var",
        "name": "countdown",
        "value": {
          "type": "Binary",
          "left": { "type": "Var", "name": "countdown" },
          "operator": "-",
          "right": { "type": "Literal", "value": 1 }
        }
      }
    ]
  }
```

Every while loop node will have a condition and a body. So when we encounter a while loop node, we know we'll need to run `while(condition) { run(body) }`. See where I'm going here?

When we were writing our lexer, we differentiated between different token types. When we were writing our parser, we differentiated between different nodes. Now, we'll differentiate between values that need to be stored in memory and values that are just literals or references to values in memory. This turns into two main methods:

<aside>
  Reminder that this all goes inside `Interpreter`.
</aside>

```js
evaluate(value, scope) {}

execute(node, scope) {}
```

`execute()` will call `evaluate()` for *evaluating* basic expressions, but `execute()` will be doing the. It's similar to the recursive descent we applied while writing our parser, except now we've condensed it down to three methods - `run()` for blocks of statements, `execute()` for those statements, and `evaluate()` for expressions.

C'mon, let's fill out `execute()`!

```js
execute(node, scope) {
  switch(node.constructor) {
    case Ast.Var:
    case Ast.Set:
    case Ast.Struct:
    case Ast.Func:
    case Ast.Return:
    case Ast.While:
    case Ast.For:
    case Ast.Conditional:
    default:
      return this.evaluate(node, scope)
  }
}
```

`node.constructor` returns the class that the node is a child of, effectively letting us check what class it belongs to.

Do you notice something? Compare this to `Parser.stmt()`, and you'll notice that they basically match up! This makes sense, since statements make changes to state.

Let's fill these out one by one. `Ast.Var`:

<aside>
  By the way, these diagrams are meant to help you understand what properties the node in question has, i.e. this node has name and value &rarr; `node.name` and `node.value`.
</aside>

<Node title="Ast.Var">
  type = "Var"

  name is Identifier

  value is Expression
</Node>

```js
case Ast.Var:
  scope[node.name] = this.evaluate(node.value, scope)
  break
```

This is pretty self-explanatory, but it looks like...

## Quick detour to evaluate

Here's our first usage of `evaluate()`! So let's take a quick detour to fill it out. It looks super similar, except we won't really be tweaking what's in `scope` here:

```js
evaluate(value, scope) {
  switch (value.constructor) {
    case Ast.Var:
        if (!this.inScope(scope, value.name))
          this.error(`${value.name} is not defined in current scope`)
        return scope[value.name]
    case Ast.Unary: {
      const operations = { '!': apply => !apply }
        return operations[value.operator](this.evaluate(value.apply, scope))
    }
    case Ast.Binary:
      const operations = {
        '<': (left, right) => left < right,
        '<=': (left, right) => left <= right,
        '>': (left, right) => left > right,
        '>=': (left, right) => left >= right,
        '!=': (left, right) => left != right,
        '==': (left, right) => left == right,
        '&&': (left, right) => left && right,
        '||': (left, right) => left || right,
        '+': (left, right) => left + right,
        '-': (left, right) => left - right,
        '*': (left, right) => left * right,
        '/': (left, right) => left / right
      }
      return operations[value.operator](
        this.evaluate(value.left, scope),
        this.evaluate(value.right, scope)
      )
    case Ast.Literal:
      return value.value
    case Ast.Array:
      return value.value.map(expr => this.evaluate(expr, scope))
    default:
      this.error("Expected expression but got statement")
  }
}
```

I started out with the most obvious ones here. If we get a reference to a variable, we'll search `scope` and return a value if it's there. If it's a unary or a binary operator, we apply the operator to the appropriate expression(s). Literals and arrays are also pretty simple.

Notice how it's recursive! Some of these also call `evaluate()` to further evaluate an expression until we get to the simplest possible value - either a reference to another value or the value itself.

## Back up the rabbit hole

Ok, let's move back up the rabbit hole now and keep working our way through `execute`:

`Ast.Struct`:

<Node title="Ast.Struct">
  type = "Struct"
  
  name is Identifier

  members is Identifier[]
</Node>

```js
case Ast.Struct:
  scope[node.name] = members => {
    // Make sure therer are no invalid keys
    let instance = {}
    for (let key of Object.keys(members)) {
      if (!node.members.includes(key))
        this.error(`Unexpected member ${key}`)
      instance[key] = members[key]
    }
    return instance
  }
  break
```

This is run when we create a struct definition, like `brush Cell has { x, y, live }`. Notice how it's a function. When we create a struct using `prep Cell(x: x, y: y, live: live)`, it's like a function, except we're passing

Where does the code for creating a struct go then? Since it evaluates to an expression (`{ x: 1, y: 1, live: false }`), we'll tackle an extra case in `evaluate()`:

```js
case Ast.Instance:
  if (!this.inScope(scope, value.name))
    this.error(`${value.name} is not defined in current scope`)

  const constructor = scope[value.name]
  let members = {}
  for (let [member, memberValue] of Object.entries(value.members))
    members[member] = this.evaluate(memberValue, scope)
  return constructor(members)
```

That's where the constructor comes into play! And notice that when we create a struct, we pass in a list of expressions rather than a list of identifiers.

`Ast.Func`:

<Node title="Ast.Func">
  type = "Func"

  name is Identifier

  params is Identifier[]

  body is Statement[]
</Node>

```js
case Ast.Func:
  const func = args => {
    let localScope = { ...scope }
    for (let [i, param] of node.params.entries())
      localScope[param] = args[i]
    try {
      this.run(node.body, localScope)
    } catch (err) {
      if (err instanceof ReturnException) return err.value
      else throw err
    }
  }

  scope[node.name] = func
  break
```

What we're doing here is pretty ingenious. (Or really, this whole thing has been quite ingenious. Seriously, pat yourself on the back for coming this far along!). We have a wrapper function - it'll take a list of arguments. We create a copy of the scope - here's where local scope comes into play! - and update the local scope with the arguments, and then use `run`. The reason why we use `run` instead of, say `execute`, is that a function is a block of statements, which is what `run` accounts for.

The extra special thing here is that we've wrapped our call to `run` with a try-catch block, but we specifically check if we get a ReturnException, and it turns out: 

`Ast.Return`:

<Node title="Ast.Return">
  type = "Return"

  value is Expression
</Node>

```js
case Ast.Return:
  throw new ReturnException(this.evaluate(node.value, scope))
```

<aside>
  Just as a reminder, return statements can be anywhere in a function, which is why exceptions work so well.
</aside>

`ReturnException` doesn't exist yet, so let's make it happen. And hopefully now the pieces are clicking into place - throwing an exception is a really useful way of exiting running a block of code, it turns out. 

```js
export class ReturnException extends Error {
  constructor(value) {
    super()
    this.value = value
  }
}
```

(Towards the top of `interpreter.js`.)

Now that we have functions that can return shtuff, we need to be able to actually call functions. This is a job for `evaluate`, since ultimately we'll use a function we find in our scope to return a value.

```js
case Ast.Call: {
  const caller = this.evaluate(value.caller, scope)
  if (!caller) this.error('Caller did not resolve to a defined value')
  let args = []
  for (let arg of value.args) args.push(this.evaluate(arg, scope))
  return caller(args)
}
```

Pretty simple, right?

`Ast.While`:

<Node title="Ast.While">
  type = "While"

  condition is Expression

  body is Statement[]
</Node>

```js
case Ast.While:
  while (this.execute(node.condition, scope)) this.run(node.body, scope)
  break
```

We've finally reached our first example! This one you probably understand now :)

`Ast.For`:

<Node title="Ast.For">
  type = "For"

  id is Identifier

  range is Expression[]

  body is Statement[]
</Node>

```js
case Ast.For:
  let localScope = { ...scope, [node.id]: this.evaluate(node.range[0]) }
  while (localScope[node.id] < this.evaluate(node.range[1], scope)) {
    this.run(node.body, localScope)
    localScope[node.id]++
  }
  break
```

For loops are really just variations on while loops. Here, we set up a local scope and inject the variable we'll use to keep track of what iteration we're on.

`Ast.Conditional`:

<Node title="Ast.Conditional">
  type = "Conditional"

  condition is Expression

  body is Statement[]

  otherwise is Ast.Conditional[]
</Node>

```js
case Ast.Conditional:
  if (this.evaluate(node.condition, scope)) this.run(node.body, scope)
  else
    for (const conditional of node.otherwise)
      this.execute(conditional, scope)
  break
```

This is pretty expected. We evaluate the condition, and if it's true, we run the if-statement's body. Otherwise, we loop through the other conditions left and do the same exact thing by recursively calling `execute()`. The useful thing is that if there is an else statement in there, we've set its condition to always be true so it'll always run if the other conditions don't match up.

`Ast.Set`:

<Node title="Ast.Set">
  type = "Set"

  name is Identifier

  property is Identifer

  value is Expression
</Node>

```js
case Ast.Set:
  if (!this.inScope(scope, node.caller))
    this.error(`${node.caller} is not defined in current scope`)
  scope[node.caller][node.property] = this.evaluate(node.value, scope)
  break
```

Of course, with a setter, one has to have a getter. That sounds like a duty for `evaluate`, of course, since we're getting a value:

<Node title="Ast.Get">
  name = "Get"

  caller is Identifier

  property is Identifier

  isExpr is boolean
</Node>

```js
case Ast.Get:
  const caller = this.evaluate(value.caller, scope)

  let get
  if (value.isExpr) get = caller[this.evaluate(value.property, scope)]
  else get = caller[value.property]

  if (get instanceof Function) return get.bind(caller)
  return get
```

We're finally going to make use of that extra `isExpr` property we've attached to our getter nodes!

But also, notice the last part of this - we have a special case for properties that actually happen to be functions - we make sure to *bind* the function to the caller. What does this mean exactly? Well, let me give you a quick example in JavaScript. Run `node` in a terminal somewhere:

```js
let test = [1, 2, 3]
let push = test.push  // References the push method on test
push(4)

// > Uncaught TypeError: Cannot convert undefined or null to object at push (<anonymous>)
```

This doesn't work because the `push` method is no longer "attached" to the original array, the caller. We don't want to run into this kind of problem, so we've just made sure to bind methods with their caller.

And that wraps up our interpreter! We've tackled every type of node our AST could possibly generate, so we're done. There's just one last step, and this one's actually a lot of fun!

## The standard library

This is great and dandy, but there's one thing we can't really do, and that is: print something to the console! What's the point of our programming language if we can't write "Hello, world!" in it and view what our values are? Not much, honestly. Let's fix that now with a standard library in `stdlib.js`:

<aside>
  By a lot of fun, I mean there's a ton of options you can add here!
</aside>

```js
export default {
  ink: args => console.log(...args),
  random: range => {
    const [min, max] = range
    return Math.random() * (max - min + 1) + min
  },
  round: number => Math.round(number)
}
```

<aside>
  Ayy. It's the answer to the meaning of life!
</aside>

Let's try it out now:

```plaintext
ink("Hello, world!")
ink(round(random(0, 100)))

---

Hello, world!
42
```

Oh smokes. Our programming language is working! ðŸŽ‰ ðŸŽ‰ ðŸŽ‰

Can we run that program that was at the beginning of this journey? Let's add a few more features to our standard library first and try again:

<aside>
  Orpheus is going to use `Canvas` and `Color` to simulate changes on a digital easel, and then map it to a real easel.
</aside>

```js
class Canvas {
  constructor(rows = 64, cols = 64) {
    this.default = { r: 0, g: 0, b: 0 }
    this.rows = rows
    this.cols = cols
    this.grid = []
    for (let i = 0; i < cols * rows; i++) this.grid.push(this.default)
  }

  get([x, y]) {
    return this.grid[y * this.cols + x]
  }

  fill([x, y, color]) {
    let cell = this.grid[y * this.cols + x]
    if (!cell)
      throw new Error(
        `Cell at (${x}, ${y}) out of range for ${this.rows}x${this.cols} canvas`
      )
    cell.r = color.r
    cell.g = color.g
    cell.b = color.b
  }

  erase([x, y]) {
    let cell = this.grid[y * this.cols + x]
    if (!cell)
      throw new Error(
        `Cell at (${x}, ${y}) out of range for ${this.rows}x${this.cols} canvas`
      )
    cell = { ...this.default }
  }
}

export default {
  Canvas: new Canvas(),
  Color: members => {
    let instance = {}
    for (let key of Object.keys(members)) {
      if (!['r', 'g', 'b'].includes(key))
        throw new Error(`Unexpected member ${key} when creating color`)
      instance[key] = members[key]
    }
    return instance
  },
  // ...
}
```

Ok! Go ahead and run `node easel.js test.easel`.

<details open>
  <summary>`test.easel`</summary>

```plaintext
prepare rows as 50
prepare cols as 20

brush Cell has { x, y, live }

~ Exercise: try setting a custom pattern instead of randomness!
sketch seed {
  prepare cells as []

  loop x through (0, rows) {
    loop y through (0, cols) {
      prepare live as false
      prepare chance as random(0, 100)
      if (chance < 20) {
        prepare live as true
      }
      cells.add(prep Cell(x: x, y: y, live: live))
    }
  }
  finished cells
}

prepare cells as seed()

sketch getNeighbors needs (cells, index) {
  ~ Get neighbors around a cell
  prepare neighbors as []

  ~ Populate neighbors
  if (index - rows - 1 > 0) {
    neighbors.add(cells[index - rows - 1])
  }
  if (index - rows > 0) {
    neighbors.add(cells[index - rows])
  }
  if (index - rows + 1 > 0) {
    neighbors.add(cells[index - rows + 1])
  }
  if (index > 0) {
    neighbors.add(cells[index - 1])
  }
  if (index < cells.length - 1) {
    neighbors.add(cells[index + 1])
  }
  if (index + rows - 1 < cells.length - 1) {
    neighbors.add(cells[index + rows - 1])
  }
  if (index + rows < cells.length - 1) {
    neighbors.add(cells[index + 1])
  }
  if (index + rows + 1 < cells.length - 1) {
    neighbors.add(cells[index + rows - 1])
  }

  prepare alive as []
  loop i through (0, neighbors.length) {
    if (neighbors[i].live) {
      alive.add(neighbors[i])
    }
  }

  finished alive
}

sketch painting {
  loop i through (0, cells.length) {
    prepare cell as cells[i]
    prepare neighbors as getNeighbors(cells, i)
    if (cell.live) {
      if (neighbors.length < 2 || neighbors.length > 3) {
        ~ Any live cell with fewer than two neighbors dies, as if by underpopulation
        ~ Any live cell with more than three live neighbors dies, as if by overpopulation
        prepare cell.live as false
      } elif (!(cell.live && neighbors == 3)) {
        ~ Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction
        prepare cell.live as true
      }
    }

    if (cell.live) {
      ~ Now draw the cell if it's alive!
      prepare color as prep Color(r: 0, g: 255, b: 0)
      Canvas.fill(cell.x, cell.y)
      ink(Canvas.get(cell.x, cell.y))
    } else {
      ~ If it's dead, turn the cell off
      Canvas.erase(cell.x, cell.y)
      ink(Canvas.get(cell.x, cell.y))
    }
  }
}

painting()

---

~ ...

{ r: 0, g: 255, b: 0}
{ r: 0, g: 0, b: 0 }
{ r: 0, g: 255, b: 0 }
{ r: 0, g: 255, b: 0 }
{ r: 0, g: 255, b: 0 }

~ ...

```
</details>

Congrats. You, you just wrote a programming language. That was pretty magical, wasn't it?

<img src="/cartoons/wizard.png" style={{ width: "40%" }} />

## What about... interactivity?

What happened to interactivity? What if we don't want to run a program from a file? Let's add a REPL (read, evaluate, print, loop) now.

<video controls>
  <source src="https://cloud-1cma98jhs-hack-club-bot.vercel.app/0screen_recording_2024-04-17_at_12_07_43_pm_adobeexpress.mp4"/>
</video>

<aside>
  Orpheus: This reminds me... we should get an easel in the terminal working. Or that could be a challenge for you.
</aside>

It's actually quite easy to do, and we have left a placeholder for it, if you remember in part one! 

![](/cartoons/repl-time.png)

Let's head on over and fill that sad and empty else-statement now. The obvious first step: let's set up the interpreter and the scope.

```js
//  ...
if (location) {
  // ...
} else {
  // Interactive REPL
  const interpreter = new Interpreter()
  let scope = {
    ...stdlib,
    exit: () => process.exit(0)
  }
}
```

I've added an extra `exit()` function so we can exit from the REPL.

Let's read a line from the terminal now. We'll need `node:readline`:

```js
import readline from "node:readline"
```

And back in the else statement:

```js
const input = readline.createInterface({
  input: process.stdin,
  output: process.stdout
})

// Remember to close stream before exiting
process.on('SIGINT', () => {
  input.close()
})

const repl = line => {
  console.log(line)
  input.question("> ", repl)
}

input.question("> ", repl)
```

There's the infinite loop we need. Now, instead of reading a file, we're going to read the line:

```js
const repl = line => {
  let hadError = false

  const lexer = new Lexer(line)
  try {
    lexer.scanTokens()
  } catch (err) {
    if (err instanceof EaselError) {
      hadError = true
      console.log(err.toString())
    }
  }

  if (!hadError) {
    const parser = new Parser(lexer.tokens)
    try {
      parser.parse()
    } catch (err) {
      if (err instanceof EaselError) console.log(err.toString())
    }

    try {
      scope = interpreter.run(parser.ast, scope)
    } catch (err) {
      if (err instanceof EaselError) console.log(err.toString())
    }
  }
}
```

The only different here, frankly, is that we introduce `hadError`. The logic is that if our lexer runs into an error, we don't want to keep going. For the parser it's a little bit different - when we run into an error, we can technically keep going because we're always guaranteed to have a valid AST (or an empty one).

And that's really all! Now you can fire up a terminal, run `node easel.js`, and boom! you have an interpreter that reads line by line.

What about multiple lines? Well, the logic behind multiple lines is that we'll check if the end of our first line is representative of a list of sorts. Basically, then: left brackets, left braces, and left parentheses. Then we'll keep reading and keeping track of the given operator until we reach the matching closing one. [TODO]

*The complete code here is at [intepreter.js](https://github.com/hackclub/langjam/blob/main/easel/interpreter.js).*